<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Block Blast Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --board-bg: #1a202c;
            --grid-bg: #2d3748;
            --text-color: #e2e8f0;
            --score-color: #f6e05e;
            --shadow-color: rgba(0, 0, 0, 0.5);
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Poppins', sans-serif;
            touch-action: none; /* Prevents scrolling on touch devices */
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 90vw;
            height: 90vw;
            max-width: 400px;
            max-height: 400px;
            background-color: var(--board-bg);
            border: 4px solid var(--grid-bg);
            border-radius: 12px;
            padding: 5px;
            gap: 3px;
            box-shadow: 0 10px 20px var(--shadow-color);
        }

        .grid-cell {
            background-color: var(--grid-bg);
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }

        .piece-container {
            width: 100px;
            height: 100px;
            cursor: grab;
            transition: transform 0.1s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .piece-container:active {
            cursor: grabbing;
            transform: scale(1.1);
        }
        
        .piece-grid {
            display: grid;
        }

        .piece-cell {
            border-radius: 3px;
        }
        
        .dragging-piece {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.9;
        }

        .cell-clearing {
            animation: clear-animation 0.5s ease-out forwards;
        }
        
        .cell-placed {
            animation: place-pop 0.3s ease-out;
        }
        
        .board-shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
        
        .power-up-pulse {
            animation: pulse-bright 1s ease-out;
        }

        @keyframes clear-animation {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.5; background-color: #fff; }
            100% { transform: scale(0); opacity: 0; }
        }
        
        @keyframes place-pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        @keyframes shake {
          10%, 90% { transform: translate3d(-1px, 0, 0); }
          20%, 80% { transform: translate3d(2px, 0, 0); }
          30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
          40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        
        @keyframes pulse-bright {
            0% { box-shadow: 0 0 0 0 rgba(250, 204, 21, 0.7); }
            70% { box-shadow: 0 0 15px 10px rgba(250, 204, 21, 0); }
            100% { box-shadow: 0 0 0 0 rgba(250, 204, 21, 0); }
        }

        .game-over-modal {
            animation: fade-in 0.5s ease;
        }
        
        .new-high-score {
            animation: pulse-yellow 1.5s infinite;
        }

        @keyframes pulse-yellow {
            0%, 100% { color: var(--score-color); transform: scale(1); }
            50% { color: #fff; transform: scale(1.1); }
        }

        @keyframes fade-in {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        
        .celebration-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            sm:font-size: 4rem;
            font-weight: bold;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.7);
            pointer-events: none;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.5s ease-out;
        }
        
        #level-up-text { color: #4ade80; } /* Green */
        #combo-text { color: #fb923c; } /* Orange */

        .celebration-text.show {
            animation: celebration-animation 1.5s ease-out forwards;
        }

        @keyframes celebration-animation {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }

        .power-up-button {
            transition: all 0.2s ease;
        }
        .power-up-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .power-up-button.active {
            box-shadow: 0 0 15px 5px #facc15;
        }
        
        /* Block Colors */
        .color-1 { background: linear-gradient(145deg, #f87171, #dc2626); box-shadow: inset 0 0 5px rgba(255,255,255,0.4), 0 2px 4px rgba(0,0,0,0.3); }
        .color-2 { background: linear-gradient(145deg, #60a5fa, #2563eb); box-shadow: inset 0 0 5px rgba(255,255,255,0.4), 0 2px 4px rgba(0,0,0,0.3); }
        .color-3 { background: linear-gradient(145deg, #4ade80, #16a34a); box-shadow: inset 0 0 5px rgba(255,255,255,0.4), 0 2px 4px rgba(0,0,0,0.3); }
        .color-4 { background: linear-gradient(145deg, #facc15, #d97706); box-shadow: inset 0 0 5px rgba(255,255,255,0.4), 0 2px 4px rgba(0,0,0,0.3); }
        .color-5 { background: linear-gradient(145deg, #a78bfa, #7c3aed); box-shadow: inset 0 0 5px rgba(255,255,255,0.4), 0 2px 4px rgba(0,0,0,0.3); }
        .color-6 { background: linear-gradient(145deg, #fb923c, #f97316); box-shadow: inset 0 0 5px rgba(255,255,255,0.4), 0 2px 4px rgba(0,0,0,0.3); }
        .color-7 { background: linear-gradient(145deg, #22d3ee, #0891b2); box-shadow: inset 0 0 5px rgba(255,255,255,0.4), 0 2px 4px rgba(0,0,0,0.3); }
        
        .preview-cell {
             background-color: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body class="bg-gray-800 text-white flex flex-col items-center justify-center min-h-screen p-2 sm:p-4">

    <!-- Start Game Modal -->
    <div id="start-modal" class="fixed inset-0 bg-gray-900 bg-opacity-95 flex flex-col items-center justify-center z-50 p-4">
        <h1 class="text-4xl sm:text-5xl md:text-6xl font-bold text-cyan-400 mb-8 animate-pulse">Block Blast</h1>
        <button id="start-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 sm:py-4 sm:px-10 rounded-lg text-xl sm:text-2xl transition duration-300 transform hover:scale-105 shadow-lg">
            Start Game
        </button>
        <div class="mt-8 flex space-x-4">
            <button id="reset-level-button" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg text-sm transition duration-300">
                Reset Level
            </button>
            <button id="reset-score-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg text-sm transition duration-300">
                Reset Top Score
            </button>
        </div>
    </div>

    <div id="game-container" class="w-full max-w-md mx-auto hidden flex flex-col h-full">
        <!-- Header -->
        <header class="mb-1 sm:mb-2 p-2 sm:p-4 bg-gray-900 rounded-lg shadow-lg">
            <div class="flex justify-between items-center">
                <h1 class="text-xl sm:text-2xl md:text-3xl font-bold text-cyan-400">Block Blast</h1>
                 <div class="text-right w-1/3">
                    <span class="text-xs sm:text-sm font-semibold text-gray-400">Level</span>
                    <div id="level" class="text-lg sm:text-xl font-bold text-white">1</div>
                    <!-- XP Bar -->
                    <div class="w-full bg-gray-700 rounded-full h-1.5 mt-1">
                        <div id="xp-progress" class="bg-green-500 h-1.5 rounded-full" style="width: 0%"></div>
                    </div>
                </div>
            </div>
            <div class="flex justify-between items-center text-center mt-2">
                <div>
                    <span class="text-xs sm:text-sm font-semibold text-gray-400">Top Score</span>
                    <div id="top-score" class="text-lg sm:text-xl font-bold text-yellow-400">0</div>
                </div>
                <div>
                    <span class="text-xs sm:text-sm font-semibold text-gray-400">Score</span>
                    <div id="score" class="text-lg sm:text-xl font-bold text-yellow-400">0</div>
                </div>
            </div>
        </header>
        
        <!-- Daily Challenge -->
        <div id="daily-challenge-container" class="mb-1 sm:mb-2 p-2 sm:p-3 bg-gray-700 rounded-lg shadow-lg text-center">
            <p class="text-xs sm:text-sm font-semibold text-cyan-400">Daily Challenge</p>
            <p id="challenge-text" class="text-sm sm:text-base text-white"></p>
            <div class="w-full bg-gray-900 rounded-full h-2.5 mt-1">
                <div id="challenge-progress" class="bg-green-500 h-2.5 rounded-full" style="width: 0%"></div>
            </div>
        </div>

        <!-- Game Board and Power-ups -->
        <div class="flex justify-center items-center flex-grow">
            <main id="game-board" class="game-board mx-auto"></main>
            <!-- Power-ups -->
            <div id="power-ups" class="flex flex-col space-y-4 ml-2 sm:ml-4">
                <button id="bomb-button" class="power-up-button bg-gray-700 p-2 rounded-full shadow-lg relative" disabled>
                    <svg class="w-6 h-6 sm:w-8 sm:h-8 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M14.12 14.12a9 9 0 1 1 0-12.24M12 12l6 6M12 12l-6-6"/>
                        <circle cx="12" cy="12" r="9"/>
                        <path d="M12 2v4M12 18v4M22 12h-4M6 12H2"/>
                    </svg>
                    <span id="bomb-count" class="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">0</span>
                </button>
                <button id="swap-button" class="power-up-button bg-gray-700 p-2 rounded-full shadow-lg relative" disabled>
                    <svg class="w-6 h-6 sm:w-8 sm:h-8 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M20 10h-5V5M4 14h5v5"/>
                        <path d="M6 18l-2-2 4-4 2 2-4 4zM18 6l2 2-4 4-2-2 4-4z"/>
                        <path d="M14 4l2.5 2.5M10 20l-2.5-2.5"/>
                    </svg>
                    <span id="swap-count" class="absolute -top-1 -right-1 bg-blue-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">0</span>
                </button>
            </div>
        </div>

        <!-- Piece Selection Area -->
        <footer id="piece-selection" class="flex justify-around items-center mt-auto h-20 sm:h-28"></footer>
    </div>

    <!-- Celebration Text Elements -->
    <div id="level-up-text" class="celebration-text">Level Up!</div>
    <div id="combo-text" class="celebration-text"></div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="game-over-modal hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
        <div class="bg-gray-800 p-6 sm:p-8 rounded-2xl shadow-2xl text-center max-w-sm w-full">
            <h2 class="text-3xl sm:text-4xl font-bold text-red-500 mb-2">Game Over</h2>
            <p id="new-high-score-text" class="text-lg sm:text-xl font-bold mb-4 hidden">New High Score!</p>
            <p class="text-base sm:text-lg text-gray-300 mb-2">Your final score is:</p>
            <p id="final-score" class="text-4xl sm:text-5xl font-bold text-yellow-400 mb-6 sm:mb-8">0</p>
            <button id="restart-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 sm:px-8 rounded-lg text-lg sm:text-xl transition duration-300 transform hover:scale-105 shadow-lg">
                Play Again
            </button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const startModal = document.getElementById('start-modal');
            const startButton = document.getElementById('start-button');
            const gameContainer = document.getElementById('game-container');
            const resetLevelButton = document.getElementById('reset-level-button');
            const resetScoreButton = document.getElementById('reset-score-button');
            const gameBoardElement = document.getElementById('game-board');
            const scoreElement = document.getElementById('score');
            const topScoreElement = document.getElementById('top-score');
            const levelElement = document.getElementById('level');
            const xpProgressElement = document.getElementById('xp-progress');
            const pieceSelectionElement = document.getElementById('piece-selection');
            const gameOverModal = document.getElementById('game-over-modal');
            const finalScoreElement = document.getElementById('final-score');
            const newHighScoreText = document.getElementById('new-high-score-text');
            const restartButton = document.getElementById('restart-button');
            const levelUpTextElement = document.getElementById('level-up-text');
            const comboTextElement = document.getElementById('combo-text');
            const bombButton = document.getElementById('bomb-button');
            const bombCountElement = document.getElementById('bomb-count');
            const swapButton = document.getElementById('swap-button');
            const swapCountElement = document.getElementById('swap-count');
            const challengeTextElement = document.getElementById('challenge-text');
            const challengeProgressElement = document.getElementById('challenge-progress');

            // --- Game Constants ---
            const BOARD_SIZE = 8;
            const PIECE_HOLDER_COUNT = 3;
            const GAP = 3; 
            const PADDING = 5;

            // --- Game State ---
            let board = [];
            let score = 0;
            let topScore = 0;
            let currentLevel = 1;
            let xp = 0;
            let xpForNextLevel = 100;
            let consecutiveClears = 0;
            let currentPieces = [];
            let draggingPiece = null;
            let dragElement = null;
            let isNewHighScore = false;
            let isAudioReady = false;
            let bombCount = 0;
            let swapCount = 0;
            let isBombMode = false;
            let dailyChallenge = {};
            let celebrationQueue = [];
            let isCelebrating = false;

            // --- Sound Synthesis ---
            const sounds = {
                place: new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 0.1 } }).toDestination(),
                clear: new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.2, sustain: 0.2, release: 0.2 } }).toDestination(),
                combo: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'fmsquare' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.2 } }).toDestination(),
                levelUp: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.2, release: 0.3 } }).toDestination(),
                gameOver: new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.5, sustain: 0.1, release: 0.5 } }).toDestination(),
                click: new Tone.MembraneSynth().toDestination(),
                powerUp: new Tone.Synth({ oscillator: { type: 'pulse' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination(),
                bomb: new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.005, decay: 0.3, sustain: 0.1 } }).toDestination(),
                swoosh: new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.01, decay: 0.15, sustain: 0 } }).toDestination()
            };

            // --- Piece Definitions by Difficulty ---
            const EASY_PIECES = [
                { shape: [[1]], w: 1, h: 1, color: 'color-1' }, { shape: [[1, 1]], w: 2, h: 1, color: 'color-2' },
                { shape: [[1], [1]], w: 1, h: 2, color: 'color-2' }, { shape: [[1, 1], [1, 1]], w: 2, h: 2, color: 'color-5' },
                { shape: [[1, 1, 1]], w: 3, h: 1, color: 'color-3' },
            ];

            const HARD_PIECES = [
                { shape: [[1, 1, 1, 1]], w: 4, h: 1, color: 'color-4' }, { shape: [[1], [1], [1], [1]], w: 1, h: 4, color: 'color-4' },
                { shape: [[1, 1, 1, 1, 1]], w: 5, h: 1, color: 'color-1' }, { shape: [[1], [1], [1], [1], [1]], w: 1, h: 5, color: 'color-1' },
                { shape: [[1,1,1],[1,1,1],[1,1,1]], w: 3, h: 3, color: 'color-4'}, { shape: [[1, 0], [1, 1]], w: 2, h: 2, color: 'color-6' },
                { shape: [[0, 1], [1, 1]], w: 2, h: 2, color: 'color-6' }, { shape: [[1, 1], [1, 0]], w: 2, h: 2, color: 'color-6' },
                { shape: [[1, 1], [0, 1]], w: 2, h: 2, color: 'color-6' }, { shape: [[1, 1, 1], [0, 1, 0]], w: 3, h: 2, color: 'color-7' },
                { shape: [[1, 1, 1], [1, 0, 0], [1, 0, 0]], w: 3, h: 3, color: 'color-1' },
            ];
            
            // --- Daily Challenges ---
            const CHALLENGES = [
                { id: 1, text: (target) => `Clear ${target} lines`, target: 15, key: 'linesCleared', reward: 5000 },
                { id: 2, text: (target) => `Score ${target} points`, target: 10000, key: 'score', reward: 7500 },
                { id: 3, text: (target) => `Achieve a Combo x${target}`, target: 4, key: 'maxCombo', reward: 10000 },
                { id: 4, text: (target) => `Place ${target} blocks`, target: 100, key: 'blocksPlaced', reward: 5000 },
            ];

            // --- Game Initialization ---
            function init() {
                score = 0;
                xp = 0;
                isNewHighScore = false;
                consecutiveClears = 0;
                bombCount = 0;
                swapCount = 0;
                updatePowerUpUI();
                setupDailyChallenge();
                loadSavedData();
                updateScore(0, true);
                
                board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(0));
                
                gameBoardElement.innerHTML = '';
                for (let i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    cell.dataset.row = Math.floor(i / BOARD_SIZE);
                    cell.dataset.col = i % BOARD_SIZE;
                    gameBoardElement.appendChild(cell);
                }

                generateNewPieces();
                gameOverModal.classList.add('hidden');
                newHighScoreText.classList.add('hidden');
                newHighScoreText.classList.remove('new-high-score');
            }

            // --- Core Game Logic ---
            function updateScore(points = 0, isInit = false) {
                if (!isInit) {
                    score += points;
                }
                scoreElement.textContent = score;
                if (score > topScore) {
                    topScore = score;
                    topScoreElement.textContent = topScore;
                    localStorage.setItem('blockBlastTopScore', topScore);
                    isNewHighScore = true;
                }
                updateChallengeProgress('score', score);
            }

            function addXP(amount) {
                xp += amount;
                if (xp >= xpForNextLevel) {
                    currentLevel++;
                    xp -= xpForNextLevel;
                    calculateXpForNextLevel();
                    localStorage.setItem('blockBlastLastLevel', currentLevel);
                    
                    if (currentLevel % 5 === 0) {
                        swapCount++;
                        updatePowerUpUI();
                        if(isAudioReady) sounds.powerUp.triggerAttackRelease("C5", "0.2");
                        swapButton.classList.add('power-up-pulse');
                        setTimeout(() => swapButton.classList.remove('power-up-pulse'), 1000);
                    }
                    if (currentLevel % 8 === 0) {
                        bombCount++;
                        updatePowerUpUI();
                        if(isAudioReady) sounds.powerUp.triggerAttackRelease("G4", "0.2");
                        bombButton.classList.add('power-up-pulse');
                        setTimeout(() => bombButton.classList.remove('power-up-pulse'), 1000);
                    }
                    queueCelebration('levelUp');
                }
                updateLevelUI();
            }

            function updateLevelUI() {
                levelElement.textContent = currentLevel;
                const progress = Math.min((xp / xpForNextLevel) * 100, 100);
                xpProgressElement.style.width = `${progress}%`;
            }

            function calculateXpForNextLevel() {
                xpForNextLevel = Math.floor(70 * Math.pow(currentLevel, 1.1));
            }

            function loadSavedData() {
                topScore = parseInt(localStorage.getItem('blockBlastTopScore')) || 0;
                currentLevel = parseInt(localStorage.getItem('blockBlastLastLevel')) || 1;
                calculateXpForNextLevel();
                topScoreElement.textContent = topScore;
                updateLevelUI();
            }
            
            function handleGameOver() {
                if (isAudioReady) sounds.gameOver.triggerAttackRelease("C3", "0.5");
                if (isNewHighScore) {
                    newHighScoreText.classList.remove('hidden');
                    newHighScoreText.classList.add('new-high-score');
                }
                finalScoreElement.textContent = score;
                gameOverModal.classList.remove('hidden');
            }
            
            function generateNewPieces() {
                pieceSelectionElement.innerHTML = '';
                currentPieces = [];
                for (let i = 0; i < PIECE_HOLDER_COUNT; i++) {
                    let piecePool = EASY_PIECES;
                    if (currentLevel >= 5) {
                        const hardChance = Math.min(0.15 + (currentLevel - 5) * 0.01, 0.80);
                        if (Math.random() < hardChance) {
                            piecePool = HARD_PIECES;
                        }
                    }
                    const pieceData = { ...piecePool[Math.floor(Math.random() * piecePool.length)] };
                    pieceData.id = i;
                    currentPieces.push(pieceData);
                    const pieceElement = createPieceElement(pieceData);
                    pieceElement.dataset.pieceId = i;
                    pieceElement.addEventListener('mousedown', startDrag);
                    pieceElement.addEventListener('touchstart', startDrag, { passive: false });
                    pieceSelectionElement.appendChild(pieceElement);
                }
                if (isGameOver()) {
                    handleGameOver();
                }
            }
            
            function isGameOver() {
                if (currentPieces.length === 0) return false;
                for (const piece of currentPieces) {
                    if (!piece) continue;
                    for (let r = 0; r <= BOARD_SIZE - piece.h; r++) {
                        for (let c = 0; c <= BOARD_SIZE - piece.w; c++) {
                            if (canPlacePiece(piece, r, c)) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }
            
            function canPlacePiece(piece, startRow, startCol) {
                for (let r = 0; r < piece.h; r++) {
                    for (let c = 0; c < piece.w; c++) {
                        if (piece.shape[r][c]) {
                            const boardRow = startRow + r;
                            const boardCol = startCol + c;
                            if (boardRow < 0 || boardRow >= BOARD_SIZE || boardCol < 0 || boardCol >= BOARD_SIZE || board[boardRow][boardCol]) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }
            
            function createPieceElement(piece) {
                const container = document.createElement('div');
                container.classList.add('piece-container');
                const grid = document.createElement('div');
                grid.classList.add('piece-grid');
                grid.style.gridTemplateColumns = `repeat(${piece.w}, 1fr)`;
                grid.style.gridTemplateRows = `repeat(${piece.h}, 1fr)`;
                const maxDim = Math.max(piece.w, piece.h, 2);
                grid.style.width = `${(piece.w / maxDim) * 80}%`;
                grid.style.height = `${(piece.h / maxDim) * 80}%`;
                for (let r = 0; r < piece.h; r++) {
                    for (let c = 0; c < piece.w; c++) {
                        const cell = document.createElement('div');
                        cell.classList.add('piece-cell');
                        if (piece.shape[r][c]) {
                            cell.classList.add(piece.color);
                        }
                        grid.appendChild(cell);
                    }
                }
                container.appendChild(grid);
                return container;
            }

            function placePiece(piece, startRow, startCol) {
                if (isAudioReady) sounds.place.triggerAttackRelease("C5", "0.1");
                let blocksPlaced = 0;
                for (let r = 0; r < piece.h; r++) {
                    for (let c = 0; c < piece.w; c++) {
                        if (piece.shape[r][c]) {
                            const boardRow = startRow + r;
                            const boardCol = startCol + c;
                            board[boardRow][boardCol] = piece.color;
                            blocksPlaced++;
                            const cell = gameBoardElement.children[boardRow * BOARD_SIZE + boardCol];
                            cell.classList.add('cell-placed');
                            setTimeout(() => cell.classList.remove('cell-placed'), 300);
                        }
                    }
                }
                updateScore(blocksPlaced);
                addXP(blocksPlaced);
                updateChallengeProgress('blocksPlaced', blocksPlaced);
                renderBoard();
                const pieceIndex = currentPieces.findIndex(p => p && p.id === piece.id);
                if (pieceIndex !== -1) {
                    currentPieces[pieceIndex] = null;
                }
                const pieceElement = pieceSelectionElement.querySelector(`[data-piece-id='${piece.id}']`);
                if (pieceElement) {
                    pieceElement.style.visibility = 'hidden';
                }
                
                const linesWereCleared = checkForLineClears();
                if (!linesWereCleared) {
                    consecutiveClears = 0;
                }

                if (currentPieces.every(p => p === null)) {
                    setTimeout(generateNewPieces, 300);
                } else {
                     if (isGameOver()) {
                        handleGameOver();
                    }
                }
            }
            
            function checkForLineClears() {
                const rowsToClear = [];
                const colsToClear = [];
                for (let r = 0; r < BOARD_SIZE; r++) {
                    if (board[r].every(cell => cell !== 0)) rowsToClear.push(r);
                }
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board.every(row => row[c] !== 0)) colsToClear.push(c);
                }
                if (rowsToClear.length > 0 || colsToClear.length > 0) {
                    clearLines(rowsToClear, colsToClear);
                    return true;
                }
                return false;
            }

            function clearLines(rows, cols) {
                consecutiveClears++;
                let linesCleared = rows.length + cols.length;
                let scoreBonus = 0;
                let xpBonus = 0;

                if (consecutiveClears > 1) {
                    scoreBonus = linesCleared * 200 * consecutiveClears;
                    xpBonus = linesCleared * 10 * consecutiveClears;
                    queueCelebration('combo', `Combo x${consecutiveClears}!`);
                } else if (linesCleared > 1) {
                    scoreBonus = linesCleared * 250;
                    xpBonus = linesCleared * 15;
                    queueCelebration('combo', 'Combo!');
                } else if (isAudioReady) {
                    sounds.clear.triggerAttackRelease("A4", "0.2");
                }

                updateScore((linesCleared * 100 + scoreBonus) * currentLevel);
                addXP(linesCleared * 10 + xpBonus);
                updateChallengeProgress('linesCleared', linesCleared);
                updateChallengeProgress('maxCombo', consecutiveClears);
                
                const clearedCells = new Set();
                rows.forEach(r => {
                    for (let c = 0; c < BOARD_SIZE; c++) clearedCells.add(`${r}-${c}`);
                });
                cols.forEach(c => {
                    for (let r = 0; r < BOARD_SIZE; r++) clearedCells.add(`${r}-${c}`);
                });
                clearedCells.forEach(coord => {
                    const [r, c] = coord.split('-').map(Number);
                    const cell = gameBoardElement.children[r * BOARD_SIZE + c];
                    cell.classList.add('cell-clearing');
                });
                setTimeout(() => {
                    rows.forEach(r => {
                        for (let c = 0; c < BOARD_SIZE; c++) board[r][c] = 0;
                    });
                    cols.forEach(c => {
                        for (let r = 0; r < BOARD_SIZE; r++) board[r][c] = 0;
                    });
                    renderBoard();
                }, 500);
            }
            
            function renderBoard() {
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        const cell = gameBoardElement.children[r * BOARD_SIZE + c];
                        cell.className = 'grid-cell';
                        cell.style.backgroundColor = ''; 
                        const colorClass = board[r][c];
                        if (colorClass) {
                            cell.classList.add(colorClass);
                        }
                    }
                }
            }

            // --- Drag and Drop Handling ---
            function startDrag(e) {
                if (isBombMode) return;
                e.preventDefault();
                const target = e.currentTarget;
                const pieceId = parseInt(target.dataset.pieceId);
                const piece = currentPieces.find(p => p && p.id === pieceId);
                if (!piece) return;
                draggingPiece = piece;
                dragElement = target.cloneNode(true);
                dragElement.classList.add('dragging-piece');
                const innerGrid = dragElement.querySelector('.piece-grid');
                if (innerGrid) {
                    innerGrid.style.width = '100%';
                    innerGrid.style.height = '100%';
                }
                const boardRect = gameBoardElement.getBoundingClientRect();
                const cellWidth = (boardRect.width - (2 * PADDING) - ((BOARD_SIZE - 1) * GAP)) / BOARD_SIZE;
                const cellHeight = (boardRect.height - (2 * PADDING) - ((BOARD_SIZE - 1) * GAP)) / BOARD_SIZE;
                dragElement.style.width = `${piece.w * cellWidth + (piece.w - 1) * GAP}px`;
                dragElement.style.height = `${piece.h * cellHeight + (piece.h - 1) * GAP}px`;
                document.body.appendChild(dragElement);
                target.style.visibility = 'hidden';
                moveDrag(e);
                document.addEventListener('mousemove', moveDrag);
                document.addEventListener('touchmove', moveDrag, { passive: false });
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchend', endDrag);
            }

            function moveDrag(e) {
                if (!draggingPiece) return;
                e.preventDefault();
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                dragElement.style.left = `${clientX - dragElement.clientWidth / 2}px`;
                dragElement.style.top = `${clientY - dragElement.clientHeight / 2}px`;
                updatePlacementPreview(clientX, clientY);
            }

            function endDrag(e) {
                if (!draggingPiece) return;
                const clientX = e.clientX || e.changedTouches[0].clientX;
                const clientY = e.clientY || e.changedTouches[0].clientY;
                const { row, col } = getBoardCoordsForPiece(clientX, clientY);
                if (row !== null && col !== null && canPlacePiece(draggingPiece, row, col)) {
                    placePiece(draggingPiece, row, col);
                } else {
                    const originalPieceElement = pieceSelectionElement.querySelector(`[data-piece-id='${draggingPiece.id}']`);
                    if(originalPieceElement) originalPieceElement.style.visibility = 'visible';
                }
                clearPlacementPreview();
                if (dragElement && dragElement.parentNode) {
                    document.body.removeChild(dragElement);
                }
                dragElement = null;
                draggingPiece = null;
                document.removeEventListener('mousemove', moveDrag);
                document.removeEventListener('touchmove', moveDrag);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchend', endDrag);
            }
            
            function getBoardCoordsForPiece(clientX, clientY) {
                if (!draggingPiece || !dragElement) return { row: null, col: null };
                const boardRect = gameBoardElement.getBoundingClientRect();
                const dragElementTopLeftX = clientX - dragElement.clientWidth / 2;
                const dragElementTopLeftY = clientY - dragElement.clientHeight / 2;
                const relativeX = dragElementTopLeftX - boardRect.left - PADDING;
                const relativeY = dragElementTopLeftY - boardRect.top - PADDING;
                const cellPlusGapX = (boardRect.width - (2 * PADDING)) / BOARD_SIZE;
                const cellPlusGapY = (boardRect.height - (2 * PADDING)) / BOARD_SIZE;
                const col = Math.round(relativeX / cellPlusGapX);
                const row = Math.round(relativeY / cellPlusGapY);
                return { row, col };
            }
            
            function updatePlacementPreview(clientX, clientY) {
                clearPlacementPreview();
                if (!draggingPiece) return;
                const { row, col } = getBoardCoordsForPiece(clientX, clientY);
                if (row === null || col === null) return;
                const canPlace = canPlacePiece(draggingPiece, row, col);
                for (let r = 0; r < draggingPiece.h; r++) {
                    for (let c = 0; c < draggingPiece.w; c++) {
                        if (draggingPiece.shape[r][c]) {
                            const boardRow = row + r;
                            const boardCol = col + c;
                            if (boardRow >= 0 && boardRow < BOARD_SIZE && boardCol >= 0 && boardCol < BOARD_SIZE) {
                                const cell = gameBoardElement.children[boardRow * BOARD_SIZE + boardCol];
                                if (cell) {
                                    cell.classList.add('preview-cell');
                                    cell.style.backgroundColor = canPlace ? 'rgba(74, 222, 128, 0.5)' : 'rgba(239, 68, 68, 0.5)';
                                }
                            }
                        }
                    }
                }
            }

            function clearPlacementPreview() {
                const previewCells = gameBoardElement.querySelectorAll('.preview-cell');
                previewCells.forEach(cell => {
                    cell.classList.remove('preview-cell');
                    cell.style.backgroundColor = '';
                });
            }
            
            // --- Power-Up Logic ---
            function updatePowerUpUI() {
                bombCountElement.textContent = bombCount;
                bombButton.disabled = bombCount <= 0;
                swapCountElement.textContent = swapCount;
                swapButton.disabled = swapCount <= 0;
            }

            function useBomb(targetCell) {
                if (isAudioReady) sounds.bomb.triggerAttackRelease("0.4");
                gameBoardElement.classList.add('board-shake');
                setTimeout(() => gameBoardElement.classList.remove('board-shake'), 500);

                const centerRow = parseInt(targetCell.dataset.row);
                const centerCol = parseInt(targetCell.dataset.col);
                let clearedCount = 0;
                for (let r = centerRow - 1; r <= centerRow + 1; r++) {
                    for (let c = centerCol - 1; c <= centerCol + 1; c++) {
                        if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                            if (board[r][c] !== 0) {
                                board[r][c] = 0;
                                clearedCount++;
                            }
                            const cell = gameBoardElement.children[r * BOARD_SIZE + c];
                            cell.classList.add('cell-clearing');
                        }
                    }
                }
                updateScore(clearedCount * 5);
                setTimeout(renderBoard, 500);
                bombCount--;
                isBombMode = false;
                bombButton.classList.remove('active');
                updatePowerUpUI();
            }

            // --- Daily Challenge Logic ---
            function setupDailyChallenge() {
                const today = new Date().toDateString();
                let savedChallengeData = JSON.parse(localStorage.getItem('dailyChallenge'));
                
                if (savedChallengeData && savedChallengeData.date === today) {
                    const savedChallenge = savedChallengeData.challenge;
                    const originalChallenge = CHALLENGES.find(c => c.id === savedChallenge.id);
                    dailyChallenge = { ...originalChallenge, completed: savedChallenge.completed };
                    challengeProgress = savedChallengeData.progress || 0;
                } else {
                    const challengeIndex = new Date().getDate() % CHALLENGES.length;
                    dailyChallenge = { ...CHALLENGES[challengeIndex], completed: false };
                    challengeProgress = 0;
                    localStorage.setItem('dailyChallenge', JSON.stringify({ date: today, challenge: { id: dailyChallenge.id, completed: false }, progress: 0 }));
                }
                
                if (dailyChallenge.completed) {
                    challengeTextElement.textContent = "Challenge completed today!";
                    challengeProgressElement.style.width = '100%';
                } else {
                    challengeTextElement.textContent = dailyChallenge.text(dailyChallenge.target);
                    const progressPercentage = Math.min((challengeProgress / dailyChallenge.target) * 100, 100);
                    challengeProgressElement.style.width = `${progressPercentage}%`;
                }
            }

            function updateChallengeProgress(key, value) {
                if (dailyChallenge.completed || !dailyChallenge.key || dailyChallenge.key !== key) return;

                if (key === 'maxCombo') {
                    challengeProgress = Math.max(challengeProgress, value);
                } else {
                    challengeProgress += value;
                }

                const progressPercentage = Math.min((challengeProgress / dailyChallenge.target) * 100, 100);
                challengeProgressElement.style.width = `${progressPercentage}%`;

                if (challengeProgress >= dailyChallenge.target) {
                    dailyChallenge.completed = true;
                    updateScore(dailyChallenge.reward);
                    queueCelebration('combo', 'Challenge Complete!');
                }
                
                const today = new Date().toDateString();
                localStorage.setItem('dailyChallenge', JSON.stringify({ date: today, challenge: { id: dailyChallenge.id, completed: dailyChallenge.completed }, progress: challengeProgress }));
            }
            
            // --- Celebration Queue Logic ---
            function queueCelebration(type, text) {
                celebrationQueue.push({ type, text });
                if (!isCelebrating) {
                    showNextCelebration();
                }
            }

            function showNextCelebration() {
                if (celebrationQueue.length === 0) {
                    isCelebrating = false;
                    return;
                }
                isCelebrating = true;
                const { type, text } = celebrationQueue.shift();
                
                let element;
                if (type === 'levelUp') {
                    element = levelUpTextElement;
                    if (isAudioReady) sounds.levelUp.triggerAttackRelease(["C4", "E4", "G4", "C5"], "0.4");
                } else {
                    element = comboTextElement;
                    element.textContent = text;
                    if (isAudioReady) sounds.combo.triggerAttackRelease(["C4", "E4", "G4", "C5"], "0.4");
                }
                
                element.classList.add('show');
                setTimeout(() => {
                    element.classList.remove('show');
                    showNextCelebration();
                }, 1500);
            }


            // --- Event Listeners ---
            restartButton.addEventListener('click', () => {
                if (isAudioReady) sounds.click.triggerAttackRelease("C2", "0.1");
                init();
            });
            
            startButton.addEventListener('click', async () => {
                if (!isAudioReady) {
                    await Tone.start();
                    isAudioReady = true;
                }
                startModal.classList.add('hidden');
                gameContainer.classList.remove('hidden');
                init();
            });
            
            resetLevelButton.addEventListener('click', () => {
                if(isAudioReady) sounds.click.triggerAttackRelease("C2", "0.1");
                localStorage.setItem('blockBlastLastLevel', '1');
                alert('Starting level has been reset to 1.');
            });

            resetScoreButton.addEventListener('click', () => {
                if(isAudioReady) sounds.click.triggerAttackRelease("C2", "0.1");
                localStorage.setItem('blockBlastTopScore', '0');
                alert('Top score has been reset to 0.');
            });

            bombButton.addEventListener('click', () => {
                if (bombCount > 0) {
                    isBombMode = !isBombMode;
                    bombButton.classList.toggle('active');
                    if (isAudioReady) sounds.click.triggerAttackRelease("E3", "0.1");
                }
            });

            swapButton.addEventListener('click', () => {
                if (swapCount > 0) {
                    if (isAudioReady) sounds.swoosh.triggerAttackRelease("0.15");
                    swapCount--;
                    updatePowerUpUI();
                    generateNewPieces();
                }
            });

            gameBoardElement.addEventListener('click', (e) => {
                if (isBombMode && e.target.classList.contains('grid-cell')) {
                    useBomb(e.target);
                }
            });

        });
    </script>
</body>
</html>
